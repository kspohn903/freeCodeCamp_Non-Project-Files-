const endsWith = word => word[word.length - 1];
const getCandidates = (words, used) => words.filter(e => 
                                                  !used.includes(e));
const buildLookup = words => {
  const lookup = new Map();
  words.forEach(e => {
    const start = e[0];
    lookup.set(start, [...(lookup.get(start) || []), e]);
  });
  return lookup;
};
const findLongestChain = names => {
  console.log(`Checking ${names.length} names`);
  const lookup = buildLookup(names);
  let maxNum = 0;
  let maxPaths = [];
  const parseResult = arr => {
    if (typeof arr[0] == 'object') {
      arr.forEach(el => parseResult(el));
    } else {
      if (arr.length > maxNum) {
        maxNum = arr.length;
        maxPaths = [arr];
      }
      if (arr.length == maxNum) { maxPaths.push(arr); }
  } };   
  const searchWords = (word, res) => {
   const cs = getCandidates(lookup.get(endsWith(word)) || [], res);
   return cs.length ? cs.map(e => searchWords(e, [...res, e])) : res;
  };
  names.forEach(word => {
    const res = searchWords(word, [word]);
    parseResult(res);
  });
  console.log(`Max Path: ${maxNum}\n`);
  console.log(`Matching Paths: ${maxPaths.length}\n`);
  console.log(`Example Path: ${maxPaths[0]}\n`);
 return maxPaths[0];
};
console.log(`Case 1: ${findLongestChain(["certain", "each", "game", "involves", "starting", "with", "word"])}\n`);
 