let topologicalSort = (libs) => {
  const D = libs.split('\n').map(e => e.split(' ').filter(ep => 
  ep != '')).reduce((p, c) => p.set(c[0], c.filter((e,i) => 
  (i > 0 && e != c[0] ? e : null) ) ), new Map());
  
  [].concat(...D.values()).forEach(e => {
    D.set(e, D.get(e) || []);
  });
  const G = [...D.keys()].reduce((p, c) =>
    p.set(c, [...D.keys()].filter(e => D.get(e).includes(c))),
    new Map() ), 
        Q = [...D.keys()].filter(e => D.get(e).length == 0), S = [];
  while (Q.length) {
    const u = Q.pop();
    S.push(u);
    G.get(u).forEach(v => {
      D.set(v, D.get(v).filter(e => e != u));
      if (D.get(v).length == 0) { Q.push(v); }
    });
  }
  return S;
};